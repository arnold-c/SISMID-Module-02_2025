{
  "hash": "4c199052c0d216198ab193f2d033a0f1",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n    html:\n        code-fold: false\n        code-line-numbers: false\n---\n\n\n\n\n# Just Enough R {.unnumbered}\n\nThe purpose of this section is to get you up-to-speed with `R`.\nIf you're completely unfamiliar with `R` and RStudio, this should provide you with enough to get started and understand what's going on in the code (and you can always refer back to this page if you understandably get a little lost), and if you have some experience, then it should provide a sufficient description of the packages and functions that we use in this workshop.\n\nNow you have `R` set installed and you can access it and are familiar with RStudio, it's time to learn some of the core features of the language.\n\n<a id=\"suggested-reading\"/>\n\n::: {.callout-tip}\nWe'd strongly recommend you read [Hands-On Programming With R](https://rstudio-education.github.io/hopr) by Garett Grolemund and [R for DataScience](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund for a deeper understanding of the following concepts (and many more).\n:::\n\n## Objects & types introduction\n\nAn object is anything you can create in R using code, whether that is a table you import from a **csv** file (that will get converted to a **dataframe**), or a **vector** you create within a script.\nEach object you create has a **type**.\nWe've already mentioned two (**dataframes** and **vectors**), but there are plenty more.\nBut before we get into object types, let's take a step back and look at types in general, thinking about individual elements and the fundamentals.\n\n## Element types\n\nGenerally in programming, we have two broad types of numbers: **floating point** and **integer** numbers, i.e., numbers with decimals, and whole numbers, respectively.\nIn `R`, we have these number types, but a **floating point** number is called a **double**.\nThe **floating point** number is the default type `R` assigns to number: look at the types assigned when we leave off a decimal place vs. specify type integer by ending a number with an `L`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=true}\nTechnically type **double** is a subset of type **numeric**, so you will often see people convert numbers to floating points using `as.numeric()`, rather than `as.double()`, but the different is semantics.\nYou can confirm this using the command `typeof(as.numeric(10)) == typeof(as.double(10))semantics.\nYou can confirm this using the command `typeof(as.numeric(10)) == typeof(as.double(10))`.\n:::\n\nInteger types are not commonly used in `R`, but there are occasions when you will want to use them e.g., when you need whole numbers of people in a simulation you may want to use integers to enforce this.\nIntegers are also slightly more precise (unless very big or small), so when exactness in whole number is required, you may want to use integers.\n\n::: {.callout-note collapse=true}\n`R` has some idiosyncrasies when it comes to numbers.\nFor the most part, **doubles** are produced, but occasionally an **integer** will be produced when you are expecting a **double**.\n\nFor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(seq(1, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(seq(1, 10, by = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\nOutside of numbers, we have **characters** (**strings**) and **boolean** types.\n\nA **boolean** (also known as a **logical** in `R`) is a `TRUE/FALSE` statement.\nIn `R`, as in many programming languages, `TRUE` is equal to a value of 1, and `FALSE` equals `0`.\nThere are times when this comes in handy e.g. you need to calculate the number of people that responded to a question, and their responses is coded as `TRUE/FALSE`, you can just sum the **vector** of responses (more on **vectors** shortly).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-tip title=\"Question\" appearance=\"minimal\"}\nCan you figure out what value will be returned for the command `(TRUE == 0) == FALSE`?\n:::\n\nA **character** is anything in quotation marks.\nThis would typically by letter, but is occasionally a number, or other symbol.\nOther languages make a distinction between **characters** and **strings**, but not `R`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(\"1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nIt is important to note that characters are not **parsed** i.e., they are not interpreted by `R` as anything other than a **character**.\nThis means that despite `\"1\"` looking like the number `1`, it behaves like a **character** in `R`, not a **double**, so we can't do addition etc. with it.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"1\" + 1\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"1\" + 1: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n\n## Object types\n### Vectors\n\nAs mentioned, anything you can create in `R` is an object.\nFor example, we can create an character object with the assignment operator (`<-`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_char_obj <- \"a\"\n```\n:::\n\n\n\n\n::: {.callout-note collapse=true}\nIn other languages, `=` is used for assignment.\nIn `R`, this is generally avoided to distinguish between creating objects (assignment), and specifying argument values (see the [section on functions](#functions)).\nHowever, despite what some purists may say, it really doesn't matter which one you use, from a practical standpoint.\n:::\n\nYou will note that when we created our object, it did not return a value (unlike the previous examples, a value was not printed).\nTo retrieve the value of the object (in this case, just print it), we just type out the object name.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_char_obj\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"\n```\n\n\n:::\n:::\n\n\n\n\nIn this case, we just create an object with only one element.\nWe can check this using the `length()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(my_char_obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\nWe could also create an **atomic vector** (commonly just called a **vector**, which we'll use from here-on in).\nIn fact, `my_char_obj` is actually an **vector**, i.e., it is a vector of length 1, as we've just seen.\nGenerally, a **vector** is an object that contains multiple elements that each have the same type.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_char_vec <- c(\"a\", \"b\", \"c\")\n```\n:::\n\n\n\n\nAs we'll see in the example below, we can give each element in a **vector** a name, and to highlight that vectors must contain elements of the same type, watch what happens here.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_named_char_vec <- c(a = \"a\", b = \"b\", c = \"c\", d = 1)\nnames(my_named_char_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_char_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   b   c   d \n\"a\" \"b\" \"c\" \"1\" \n```\n\n\n:::\n:::\n\n\n\n\nBecause `R` saw the majority of the first elements in the **vector** were of type **character** it **coerced** the number to a **character**.\nThis is super important to be aware of, as it can cause errors, particularly when coercion goes in the other direction i.e. trying to create a **numeric vector**.\n\n#### Factors\n\nAll the **vector** types we've mentioned so far map nicely to their corresponding **element** types.\nBut there is an extension of the **character** vector used frequently: the **factor** (and, correspondingly, the **ordered** vector).\n\nA **factor** is a **vector** where there are distinct groups that exist within a **vector** i.e., they are *nominal categorical data*.\nFor example, we often include gender as a covariate in epidemiological analysis.\nThere is no intrinsic order, but we would want to account for the groups in the analysis.\n\nAn **ordered vector** is when there *is* an intrinsic order to the grouping i.e., we have *ordinal categorical data*.\nIf, for example, we were interested in how the frequency of cigarette smoking is related to an outcome, and we wanted to use *binned* groups, rather than treating it as a continuous value, we would want to create an **ordered vector** as the ordering of the different groupings is important.\n\nLet's use the `mtcars` dataset (that comes installed with `R`), and turn the number of cylinders (`cyl`) into an **ordered vector**, as there are discrete numbers of cylinders a car engine can have, *and* the ordering matters.\nDon't worry about what `$` is doing; we'll come to that [later](#indexing-objects)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mtcars <- mtcars\nmy_mtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_mtcars$cyl <- ordered(my_mtcars$cyl)\nmy_mtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\nLevels: 4 < 6 < 8\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to directly specify the ordering of the groups, we can do this using the `levels` argument i.e.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mtcars$cyl <- ordered(my_mtcars$cyl, levels = c(8, 6, 4))\nmy_mtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\nLevels: 8 < 6 < 4\n```\n\n\n:::\n:::\n\n\n\n\nTo create a **factor**, just replace the `ordered()` call with `factor()`\n\n\n### Lists\n\nThere is another type of **vector**: the **list**.\nMost people do not refer to **lists** as type of **vectors**, so we will only refer to them as **lists**, and **atomic vectors** will just be referred to as **vectors**.\n\nUnlike **vectors** there are no requirements about the form of **lists** i.e., each element of the **list** can be completely different.\nOne element could store a **vector** of numbers, another a model object, another a **dataframe**, and another a **list** (i.e. a nested **list**).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\n    c(1, 2, 3, 4, 5),\n    glm(mpg ~ ordered(cyl) + disp + hp, data = mtcars),\n    data.frame(column_1 = 1:5, column_2 = 6:10)\n)\nmy_named_list <- list(\n    my_vec = c(1, 2, 3, 4, 5),\n    my_model = glm(mpg ~ ordered(cyl) + disp + hp, data = my_mtcars),\n    my_dataframe = data.frame(column_1 = 1:5, column_2 = 6:10)\n)\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n\nCall:  glm(formula = mpg ~ ordered(cyl) + disp + hp, data = mtcars)\n\nCoefficients:\n   (Intercept)  ordered(cyl).L  ordered(cyl).Q            disp              hp  \n      28.98802        -1.71963         2.31169        -0.02604        -0.02114  \n\nDegrees of Freedom: 31 Total (i.e. Null);  27 Residual\nNull Deviance:\t    1126 \nResidual Deviance: 225.1 \tAIC: 165.2\n\n[[3]]\n  column_1 column_2\n1        1        6\n2        2        7\n3        3        8\n4        4        9\n5        5       10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$my_vec\n[1] 1 2 3 4 5\n\n$my_model\n\nCall:  glm(formula = mpg ~ ordered(cyl) + disp + hp, data = my_mtcars)\n\nCoefficients:\n   (Intercept)  ordered(cyl).L  ordered(cyl).Q            disp              hp  \n      28.98802         1.71963         2.31169        -0.02604        -0.02114  \n\nDegrees of Freedom: 31 Total (i.e. Null);  27 Residual\nNull Deviance:\t    1126 \nResidual Deviance: 225.1 \tAIC: 165.2\n\n$my_dataframe\n  column_1 column_2\n1        1        6\n2        2        7\n3        3        8\n4        4        9\n5        5       10\n```\n\n\n:::\n:::\n\n\n\n\nSimilar to **vectors**, **lists** can be named, or unnamed, and also that we they display in slightly different ways: when unnamed, we get the notation `[[1]] ... [[3]]` to denote the different **list** elements, and with the **named list** we get `$my_vec ... $my_dataframe`.\nIt is often useful to name them, though, as it gives you some useful options when it comes to indexing and extracting values later.\n\n::: {.callout-note collapse=true}\nIf you're wondering why we are creating our list elements with the `=` operator, that's because we can think of this as an argument in the `list()` function, where the argument name is the name we want the element to have, and the argument value is the element itself.\n:::\n\n### Dataframes\n\n**Dataframes** are the last key object type to learn about.\nA **dataframe** is technically a special type of list.\nEffectively, it is a 2-D table where every column has to have elements of the same type (i.e., is a **vector**), but the columns can be different types to each other.\nThe other important restriction is that all columns must be the same length, i.e. we have a rectangular **dataframe**.\n\nAs we've seen before, we can create a dataframe using this code, where `1:5` is shorthand for a vector that contains the sequence of numbers from 1 to 5, inclusive (i.e., `c(1, 2, 3, 4, 5)`).\nWe could also write this sequence as `seq(1, 5, by = 1)`, allowing us more control over the steps in the sequence.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dataframe <- data.frame(\n    column_int = 1:5,\n    column_dbl = seq(6, 10, 1),\n    column_3 = letters[1:5]\n)\n```\n:::\n\n\n\n\nLike with every other object type, we can just type in the **dataframe's** name to return it's value, but this tim, let' explore the *structure* of the **dataframe** using the `str()` function.\nThis function can be used on any of the objects we've seen so far, and is particularly helpful when exploring **lists**.\nOne nice feature of **dataframes** is that it will explicitly print the columns types.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_dataframe)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t5 obs. of  3 variables:\n $ column_int: int  1 2 3 4 5\n $ column_dbl: num  6 7 8 9 10\n $ column_3  : chr  \"a\" \"b\" \"c\" \"d\" ...\n```\n\n\n:::\n:::\n\n\n\n\n### Matrices\n\n**Matrices** are crucial to many scientific fields, including epidemiology, as they are the basis of linear algebra.\nThis course will use **matrix** multiplication extensively (notably [R Session 2](r-session-02.qmd)), so it is worth knowing how to create matrices.\n\nMuch like vectors, all elements in a **matrix** should be the same type (or they will be coerced if possible, resulting in `NA` if not).\nIt is unusual to have a **non-numeric matrix** e.g., a **character matrix**, but it is possible.\nWhen we create our **matrix**, notice that it fills column-first, much like how we think of **matrices** in math (i.e., `i` then `j`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(1:8, nrow = 2)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n\n\n:::\n:::\n\n\n\n\n## Indexing objects\n### Indexing operators\n\nWe've got our objects, but now we want to do stuff with them.\nWithout getting into too much detail about *Object-Oriented Programming* (e.g., the `S3` class system in `R`), there are three mains ways of indexing in `R`:\n\n- The single bracket `[]`\n- The double bracket `[[]]`\n- The dollar sign `$`\n\nWhich method we use depends on the type of object we have.\nHandily, `[]` will work for pretty much everything, and we typically only use use `[[]]` for **lists**.\n\n### Indexing vectors\n\nWith both `[]` and `[[]]`, we can use the *indices* i.e., the numbered position of the specific values/elements we want to extract, but if we have named objects, we can pass the names to the `[]` in a **vector**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract elements 1 through 3 inclusively\nmy_char_vec[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the same elements but using their names in a vector\nmy_named_char_vec[c(\"a\", \"b\", \"c\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   b   c \n\"a\" \"b\" \"c\" \n```\n\n\n:::\n:::\n\n\n\n\nNotice that when we index the named **vector** we get *both* the name *and* the value returned.\nMany times this is OK, but if we only wanted the value, then you'd index with `[[]]`, but it is important to note that you can only pass *one* value to the brackets.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_named_char_vec[[c(\"a\", \"b\")]]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_named_char_vec[[c(\"a\", \"b\")]]: attempt to select more than one element in vectorIndex\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_char_vec[[\"a\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"\n```\n\n\n:::\n:::\n\n\n\n\nIf you're wondering why go through the hassle, it's because values can change position in the list when we update inputs, such as **csv** datafiles, or needing to restructure code to make something else work.\nIf we only index with the numeric indices, we run the risk of a silent error being returned i.e., a value is provided to us, but we don't know that it's referring to the wrong thing.\nIndexing with names mean that the element's position in the **vector** doesn't matter, and if it's accidentally been removed when we updated code, and error will be explicitly thrown as it won't be able to find the index.\n\n### Lists and Dataframes\n\nWhen it comes to indexing **lists** and **dataframes** (remember, **dataframes** are just special **lists**, so the same methods are available to us), it is more common to use `[[]]` and `$`, though there are obviously occasions when `[]` is useful.\nLet's look at `my_named_list` first.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_named_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$my_vec\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list[\"my_vec\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$my_vec\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list[[\"my_vec\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_named_list$my_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note}\nIn the examples above, notice how both `[]` methods returned the name of the element as well as the values (as it did before with the named **vector**).\nThis is important as it means we need to extract the values from what is returned before we can do any further indexing i.e., to get the value `3` from the **list** element `my_vec`.\n:::\n\nWe can do the same with the unnamed **list**, except the last two methods are not available as we do not have a name to use.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\nBecause a **dataframe** is a type of list where the column headers are the element names, we can use `[[]]` and `$` as with the named list.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dataframe[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [5, 1]\ncolumn_int int 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dataframe[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dataframe[\"column_int\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [5, 1]\ncolumn_int int 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dataframe$column_int\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to extract a particular value from a column, we can use the following methods.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# indexes i then j, just like in math\nmy_dataframe[2, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the second element from the first column\nmy_dataframe[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the second element from column_int, using the i, j procedure as before\nmy_dataframe[2, \"column_int\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the second element from column_int\nmy_dataframe$column_int[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n## Packages\n\nUp until now, we've been getting to grips with the core concepts of objects, and indexing them.\nBut when you're writing code, you'll want to do things that are relatively complicated to implement, such as solve a set of differential equations.\nFortunately, for many areas of computing (and, indeed, epidemiology and statistics), many others have also struggled with the same issues and some have gone one to document their solutions in a way others can re-use them.\nThis is the basis for **packages**.\nSomeone has *packaged up* a set of functions for others to re-use.\n\nWe've mentioned the word **function** a number of time so far, and we haven't defined it, but that's [coming soon](#functions).\nFor the moment, let's just look at how we can find, install, and load **packages**.\n\n### Finding packages\n\nAs [mentioned previously](install-r.qmd#r) CRAN is a place where many pieces of `R` code is documents and stored for others to download and use.\nNot only are the `R` programming language executables stored in CRAN, but so are user-defined **functions** that have been turned into **packages**.\n\nTo find packages, you can go to the CRAN website and search by name, but there are far too many for that to be worthwhile - just Google what you want to do and add \"r\" to the end of your search query, and you'll likely find what you're looking for.\nOnce you've found a package you want to download, next you need to install it.\n\n### Installing packages\n\nBarring any super-niche packages, you should be able to use the following command(s):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"package to download\")\n# Download multiple by passing a vector of package names\ninstall.packages(c(\"package 1\", \"package 2\"))\n```\n:::\n\n\n\n\nIf for some reason you get an error message saying the package isn't available on CRAN, first, check for typos, and if you still get an error, you may need to download it directly from GitHub.\nRead [here](https://pak.r-lib.org/dev/reference/get-started.html#install-a-package-from-github) for more information about using the `{pak}` package to download packages from other sources.\n\n### Loading packages\n\nNow you have your packages installed, you just need to load them to get any of their functionality.\nThe easiest way is to place this code at the top of your script.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Quotations are not required, but can be used\nlibrary(package to download)\n```\n:::\n\n\n\n\n<a id=\"namespace-conflict\"/>\n\nMost of the time, this is fine, but occasionally you will run in to an issue where a function doesn't work as expected.\nSometimes this is because of what's called a *namespace conflict* i.e., you have two functions with the same name loaded, and potentially you're using the wrong verion.\n\nFor example, in base `R` (i.e, these functions come pre-installed when you set up `R`), there is a `filter()` function from the `{stats}` package (as mentioned, we'll denote this as `stats::filter()`).\nThroughout this workshop, you will see `library(tidyverse)` at the top of the pages to indicate the `{tidyverse}` set of packages are being loaded (this is actually a package that installs a bunch of related and useful packages for us).\nIn `{dplyr}` (one of the packages loaded by `{tidyverse}`) there is also a function called `filter()`.\nBecause `{dplyr}` was loaded after `{stats}` was loaded (because `{stats}` is automatically loaded when `R` is started), the `dplyr::filter()` function will take precedence.\nIf we wanted to specifically use the `{stats}` version, we could write this:\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\n# Set the seed for the document so we get the same random numbers sampled\n# each time we run the script (assuming it's run in its entirety from start\n# to finish)\nset.seed(1234)\n\n# Create a cosine wave with random noise\nraw_timeseries <- cos(pi * seq(-2, 2, length.out = 1000)) + rnorm(1000, sd = 0.5)\n\n# Calculate 20 day moving average using stats::filter()\nsmooth_timeseries <- stats::filter(raw_timeseries, filter = rep(1/20, 20), sides = 1)\n\n# Plot raw data\nplot(raw_timeseries, col = \"grey80\")\n\n# Overlay smoothed data\nlines(smooth_timeseries, col = \"red\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-25-1.png){width=100%}\n:::\n:::\n\n\n\n\n## Functions\n\nAs we've alluded to, **functions** are core to gaining *functionality* in `R`.\nWe can always hand-write the code to complete a task, but if we have to repeat a task more than once, it can be tiresome to repeat the same code, particularly if it is a particularly complex task that requires many lines of code.\nThis is where **functions** come in: they provide us with a mechanism to wrap up code into something that can be re-used.\nNot only does this reduce the amount of code we need to write, but by minimize code duplication, debugging becomes a lot easier as we only need to remember to make changes and correct one section of our codebase.\nSay, for example, you want to take a vector of numbers and calculate the cumulative sum e.g.; \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dbl_vec <- 1:10\n\ncumulative_sum <- 0\n\nfor(i in seq_along(my_dbl_vec)) {\n    cumulative_sum <- cumulative_sum + i\n}\n\ncumulative_sum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\nThis is OK if we only do this calculation once, but it's easy to imagine us wanting to repeat this calculation; for example, we might use calculate the cumulative sum of daily cases to get a weekly incidence over every week of a year.\nIn this situation, we would want to create a function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_cumsum <- function(vector) {\n    cumulative_sum <- 0\n\n    for(i in seq_along(my_dbl_vec)) {\n        cumulative_sum <- cumulative_sum + i\n    }\n\n    cumulative_sum\n}\n\nmy_cumsum(my_dbl_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note collapse=true}\nThis is obviously a contrived example because, as with many basic operations in `R`, there is already a function written to perform this calculation that does it in a much more performant and safer manner: `cumsum()`\n:::\n\nFor many of the manipulations we will want to perform, a **function** has already been written by someone else and put into a **package** that we can download, as we've [already seen](#packages).\n\n### Anonymous functions\n\nThere is a special class of functions called anonymous functions that are worth being aware of, as we will use them quite extensively throughout this workshop.\nAs the name might suggest, **anonymous functions** are functions that are not named, and therefore, not saved for re-use.\nYou may, understandably, be wondering why we would want to use them, given we just make the case for functions replacing repeatable blocks of code.\nIn some instances, we want to be able to perform multiple computations that require creating intermediate objects, but because we only need to use them once, we don't save them save to our environment, potentially causing issues with conflicts (e.g., accidentally using an object we didn't mean to, or overwriting existing ones by re-using the same object name).\nThis gets into the broader concept of local vs global scopes, but that is too far beyond the scope of this workshop: see [Hands-On Programming with R](https://rstudio-education.github.io/hopr/environments.html#scoping-rules) and [Advanced R](https://adv-r.hadley.nz/functions.html?q=lexical#lexical-scoping) for more information.\nLet's look at an example to see when we might want to use an anonymous function.\n\nThroughout this workshop, we will make use of the `map_*()` series of functions from the `{purrr}` package.\nWe'll go into more detail about `purr::map()` [shortly](#sec-map-functions), but for now, imagine we have a **vector** of numbers, and we want to add `5` to each value before and multiplying by `10`.\nThe `map_dbl()` function takes a **vector** and a function, and outputs a **double vector**.\nWe could write a function to perform this multiplication, but if we're only going to do this operation once, it seems unnecessary.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dbl(\n    .x = my_dbl_vec,\n    .f = function(.x) {\n        add_five_val <- .x + 5\n\n        add_five_val * 10\n    }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  60  70  80  90 100 110 120 130 140 150\n```\n\n\n:::\n\n```{.r .cell-code}\n# only exists within the function\nadd_five_val\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'add_five_val' not found\n```\n\n\n:::\n:::\n\n\n\n\nHere, we've specified the anonymous function to take the input `.x` and multiple each value by 10, and we did it without saving the function.\nThis would be equivalent to writing this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_five_multiply_ten <- function(x) {\n    add_five_val <- x + 5\n    add_five_val * 10\n}\n\npurrr::map_dbl(\n    .x = my_dbl_vec,\n    .f = ~add_five_multiply_ten(.x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  60  70  80  90 100 110 120 130 140 150\n```\n\n\n:::\n\n```{.r .cell-code}\n# only exists within the function\nadd_five_val\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'add_five_val' not found\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-warning}\nNotice the `~` used: this specifies that we want to pass arguments into our named function.\nWithout it, we will get an error about `.x` not being found.\n:::\n\n::: {.callout-note collapse=true}\nIn this example, because we are doing standard arithmetic, `R` will **vectorize** our function so that it can automatically be applied to each element of the object, so this example was merely to illustrate the point.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_five_multiply_ten(my_dbl_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  60  70  80  90 100 110 120 130 140 150\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## Tidy data\n\nBefore we look at the common packages and functions we use throughout this workshop, let's take a second to talk about how our data is structured.\nFor much of what we do, it is convenient to work with **dataframes**, and many functions we will use are designed to work with *long* **dataframes**.\nWhat this means is that each *column* represents a variable, and each row is a unique observation.\n\nLet's first look at a **wide dataframe** to see how data may be represented.\nHere, we have one column representing a number for each of the states in the US, and then we have two columns representing some random incidence: one for July and one for August.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwide_df <- data.frame(\n    state_id = 1:52,\n    july_inc = rbinom(52, 1000, 0.4),\n    aug_inc = rbinom(52, 1000, 0.6)\n)\n\nwide_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 3]\nstate_id int 1 2 3 4 5 6\njuly_inc int 399 409 381 381 387 372\naug_inc  int 613 578 604 607 603 614\n```\n\n\n:::\n:::\n\n\n\n\nInstead, we reshape this into a **long dataframe** so that there is a column for the state ID, a column for the month, and a column for the incidence (that is associated with *both* the state *and* the month).\nUsing the `{tidyr}` package, we could reshape this **wide dataframe** to be a **long dataframe** (see [this section](#sec-pivot-functions) for more information about the `pivot_*()` functions)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_df <- tidyr::pivot_longer(\n    wide_df,\n    cols = c(july_inc, aug_inc),\n    names_to = \"month\",\n    values_to = \"incidence\",\n    # Extract only the month using regex\n    names_pattern = \"(.*)_inc\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n{paint} masked print.tbl_df\n```\n\n\n:::\n\n```{.r .cell-code}\nlong_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [104, 3]\nstate_id  int 1 1 2 2 3 3\nmonth     chr july aug july aug july aug\nincidence int 399 613 409 578 381 604\n```\n\n\n:::\n:::\n\n\n\n\nYou will notice that our new dataframe contains three columns still, but is longer than previously; two time as long, in fact.\n\n::: {.callout-note collapse=true}\nParticularly keen-eyed reader may also notice that `long_df` is also has class **tibble**, not a **data.frame**.\nA **tibble** effectively is a **data.frame**, but is an object commonly used and output by `{tidyverse}` functions, as it has a few extra safety features over the base **data.frame**.\n:::\n\n\n## Core code used\n\nWe're finally ready to talk about the functions that are used throughout this workshop.\nThe first package to mention is the `{tidyverse}` package, which actually a collection of packages: the core packages can be found [here](https://www.tidyverse.org/packages/).\nThe reason why are using the `{tidyverse}` packages throughout this workshop is that they are relatively easily to learn, compared to base `R` and `{data.table}` (not that they are mutually exclusive), and what most people are familiar with.\nThey also are well designed and powerful, so you should be able to do most things you need using their packages.\n\nYou can find a list of cheatsheets for all of these packages (and more) [here](https://posit.co/resources/cheatsheets/?type=posit-cheatsheets&_page=1/).\n\nLet's load the `{tidyverse}` packages and then go through the key functions used.\nUnless stated explicitly, these packages will be available to you after loading the `{tidyverse}` with the following command.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n### `tibble()`\n\nThe **tibble** is a modern reincarnation of the **dataframes** that is slightly safer i.e., is more restricted in what you can do with it, and will throw errrors more frequently, but very rarely for anything other than a bug.\nWe will use the terms interchangeably, as most people will just talk about **dataframes**, as for the most part, they can be treated identically.\nUse the same syntax as the `data.frame()` function to create the **tibble**.\n\n### `dplyr::filter()`\n\nIf we wanted to take a subset of rows of a **dataframe**, we would use the `dplyr::filter()` function.\nHere, we're listing the package it's coming from, as there are some other packages that also export their own version of the `filter()` function.\nHowever, for all the code in this workshop, there aren't any concerns about [**namespace conflicts**](#namespace-conflict), so we won't use it from here on in.\n\nThe `filter()` function is relatively simple to work with: you specify the **dataframe** variable you want to subset by, the filtering criteria, and that's it.\nIf we include multiple arguments, they get treated as *AND* statements (`&`), so all conditions need to be met.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n    long_df,\n    month == \"july\",\n    incidence > 410\n    # equivalent to: month == \"july\" & incidence > 410\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [8, 3]\nstate_id  int 10 14 34 38 42 45\nmonth     chr july july july july july july\nincidence int 422 421 422 426 441 417\n```\n\n\n:::\n:::\n\n\n\n\nWe can filter using *OR* statements (`|`), so if either condition returns `TRUE`, then it will be included in the subset.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(\n    long_df,\n    month == \"july\" | incidence > 600\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [78, 3]\nstate_id  int 1 1 2 3 3 4\nmonth     chr july aug july july aug july\nincidence int 399 613 409 381 604 381\n```\n\n\n:::\n:::\n\n\n\n\n\n### `select()`\n\nIf, instead, we wanted to subset of columns of a **dataframe**, we would use the `dplyr::select()` function.\n\nLet's say, from our wide incidence data, we only want the state's ID and their August incidence.\nWe can directly select the columns this way.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n    wide_df,\n    state_id, aug_inc\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 2]\nstate_id int 1 2 3 4 5 6\naug_inc  int 613 578 604 607 603 614\n```\n\n\n:::\n:::\n\n\n\n\nBut in this case, it would be more efficient (for us) to tell `R` the columns we *don't* want.\nWe can do that using the `-` sign.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n    wide_df,\n    -july_inc\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 2]\nstate_id int 1 2 3 4 5 6\naug_inc  int 613 578 604 607 603 614\n```\n\n\n:::\n:::\n\n\n\n\nIf there were multiple columns we didn't want, we would pass them in a vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(\n    wide_df,\n    -c(july_inc, aug_inc)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 1]\nstate_id int 1 2 3 4 5 6\n```\n\n\n:::\n:::\n\n\n\n\nWhen it comes to selecting columns, the `{tidyselect}` package has a few very handy functions for us.\nTo understand when they are most useful, let's first look at the `mutate()` function, and then we'll highlight how to use the different column selection functions available to use through `{tidyselect}`.\n\n### `mutate()`\n\nIf we have a **dataframe** and want to add or edit a column, we use the `mutate()` function.\nUsually the `mutate()` function is used to add a column that is related to the existing data, but it is not necessary.\nBelow are examples of both.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add September incidence that is based on August incidence\nmutate(\n    wide_df,\n    sep_inc = round(aug_inc * 1.2 + rnorm(52, 0, 10), digits = 0)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 4]\nstate_id int 1 2 3 4 5 6\njuly_inc int 399 409 381 381 387 372\naug_inc  int 613 578 604 607 603 614\nsep_inc  dbl 735 692 725 733 733 740\n```\n\n\n:::\n\n```{.r .cell-code}\n# add random September incidence\nmutate(\n    wide_df,\n    sep_inc = rbinom(52, 1000, 0.7)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 4]\nstate_id int 1 2 3 4 5 6\njuly_inc int 399 409 381 381 387 372\naug_inc  int 613 578 604 607 603 614\nsep_inc  int 702 722 711 709 684 682\n```\n\n\n:::\n:::\n\n\n\n\nIf we wanted to update a column, we can do that by specifying the column on both sides of the equals sign.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Update the August incidence to add random noise\nmutate(\n    wide_df,\n    aug_inc = aug_inc + round(rnorm(52, 0, 10), digits = 0)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 3]\nstate_id int 1 2 3 4 5 6\njuly_inc int 399 409 381 381 387 372\naug_inc  dbl 609 587 614 616 577 605\n```\n\n\n:::\n:::\n\n\n\n\nOne crucial thing to note is that `mutate()` applies our function/operation to each row simultaneously, so the new column's value only depends on the *row's* original values (or the vector in the case of the second example that didn't use the values from the data).\n\n### `paste0()`\n\nThe `paste0()` function is useful for manipulating objects and coercing them into string, allowing us to do *string interpolation*.\nIt comes installed with base `R`, so there's nothing to install, and because of the way `mutate()` works, apply functions to each row simultaneously, we can modify whole columns at once, depending on the row's original values.\nIt works to *squish* all the values together, without any separators by default.\nIf you wanted spaces between your words, for example, you can use the `paste(..., sep = \" \")` function, which takes the `sep` argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchar_df <- mutate(\n    long_df,\n    # Notice that text is in commas, and object values being passed to paste0()\n    # are unquoted.\n    state_id = paste0(\"state_\", state_id)\n)\n\nchar_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [104, 3]\nstate_id  chr state_1 state_1 state_2 state_2 state_3 state_3\nmonth     chr july aug july aug july aug\nincidence int 399 613 409 578 381 604\n```\n\n\n:::\n:::\n\n\n\n### `glue::glue()` {#sec-glue}\n\n`glue()` is a function that comes installed with `{tidyverse}`, but is not loaded automatically, so you have to reference it explicitly by either using `library(glue)` or the `::` notation shown below.\nIt serves the same purpose as the base `paste0()`, but in a slightly different syntax.\nInstead of using a mix of quotations and unquoted object names, `glue()` requires everything to be in quotation marks, with any value being passed to the *string interpolation* being *enclosed* in `{ }`.\nIt is worth learning `glue()` as it is used throughout the `{tidyverse}` packages, such as in the `pivot_wider()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchar_df <- mutate(\n    long_df,\n    state_id = glue::glue(\"state_{state_id}\")\n)\n\nchar_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [104, 3]\nstate_id  chr state_1 state_1 state_2 state_2 state_3 state_3\nmonth     chr july aug july aug july aug\nincidence int 399 613 409 578 381 604\n```\n\n\n:::\n:::\n\n\n\n\n### `str_replace_all()`\n\nIf we want to replace characters throughout the whole of a string vector, we can do that with the `str_replace_all()` function.\nAnd because **dataframes** are made up of individual **vectors**, we can use this to modify vectors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    char_df,\n    # pass in the vector (a column, here), the pattern to remove, and the replacement\n    clean_state_id = str_replace_all(state_id, \"state_\", \"\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [104, 4]\nstate_id       chr state_1 state_1 state_2 state_2 state_3 state_3\nmonth          chr july aug july aug july aug\nincidence      int 399 613 409 578 381 604\nclean_state_id chr 1 1 2 2 3 3\n```\n\n\n:::\n:::\n\n\n\n\n### `across()`\n\nAbove, we were only **mutating** a single column at a time, which is what we often do.\nBut, sometimes we want to apply the exact same transformation to multiple columns.\nFor example, say we wanted to turn our monthly incidence data into the average weekly incidence.\nWe could write out each transformation by hand, but when there are more than two columns, this gets rather tedious and introduces the opportunity for mistakes when copying code (one of our motivations for using functions).\nThe `tidyselect::across()` function allows us to specify the columns we want to apply the transformation, and the function (can be named or anonymous), and that's it.\n\nThere are a couple of points to understand about the code below:\n\n- Note the `.` preceding the `cols`, `fns`, and `x`\n- Each column is passed to the `.x` value in the function argument\n- `~` is required to pass arguments into the function. In this case it is an anonymous function using the [`map_*()` syntax](#sec-map-functions).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    wide_df,\n    across(\n        .cols = c(july_inc, aug_inc),\n        .fns = ~.x * 7 / 30\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 3]\nstate_id int 1 2 3 4 5 6\njuly_inc dbl 93.1 95.433333 88.9 88.9 90.3 86.8\naug_inc  dbl 143.033333 134.866667 140.933333 141.633333 140.7 143.266667\n```\n\n\n:::\n:::\n\n\n\n\n### `everything()`\n\nIf we wanted to select every column in a dataframe, we would use the `everything()` function.\nThis may not seem helpful initially, but there are occasions when it's very useful.\nFor instance, in the previous example we still specified the exact columns we wanted to transform.\nHowever, if there were five times as many, we wouldn't want to do that.\nDo note that if we replaced this with `everything()`, we would also `mutate()` our `state_id` column, which we probably don't want to do, so we could combine it with the `-` selection seen previously.\n\n### `contains()`\n\nAnother very handy function is the `tidyselect::contains()` function.\nThis allows us to specify a string that the column names must *contain* for them to be selected.\nWe could change the above example to look like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    wide_df,\n    across(\n        .cols = contains(\"_inc\"),\n        .fns = ~.x * 7 / 30\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 3]\nstate_id int 1 2 3 4 5 6\njuly_inc dbl 93.1 95.433333 88.9 88.9 90.3 86.8\naug_inc  dbl 143.033333 134.866667 140.933333 141.633333 140.7 143.266667\n```\n\n\n:::\n:::\n\n\n\n\n### `rename_with()`\n\nIf we wanted to rename columns of a **dataframe**, we can use the `rename()` function.\nHowever, like the previous `{tidyselect}` examples, sometimes we want to apply the same renaming scheme (function) to the columns.\n`rename_with()` allows us to pass a function to multiple columns at once, achieving what we want with minimal effort, and without needing to use `across()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename_with(\n    wide_df,\n    .cols = contains(\"_inc\"),\n    .fn = ~str_replace_all(.x, \"_inc\", \"_incidence\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [52, 3]\nstate_id       int 1 2 3 4 5 6\njuly_incidence int 399 409 381 381 387 372\naug_incidence  int 613 578 604 607 603 614\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-important}\nHopefully you are noticing a pattern between the `{tidyselect}`-type functions.\nWhen you need to apply a function to multiple columns in a **dataframe**, you will select the columns with the `.cols` argument, and pass the function to the `.fn(s)` argument with the `~` symbol indicating you are using the `.x` to represent the column in the function (yes, there is a touch of ambiguity between `.fns` and `.fn`, but the general pattern holds).\nThis will be useful when we look at the `map_*()` family of functions.\n:::\n\n### `magrittr::%>%`\nThe `%>%` operator is an interesting and very useful function that comes installed (and loaded) with the `{tidyverse}` package (technically from the `{magrittr}` package from within the `{tidyverse}`).\nIt allows us to chain together operations without needing to create intermediate objects.\nSay for example we have our wide incidence data and want to add data for September before turning it into a **long dataframe**, we could create and intermediate object before using the `pivot_longer()` function from before, but we might not want to create another object that we don't really care about.\nThis is when we would want to use a pipe, as it takes the output of one operation and *pipes* it into the next one.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    wide_df,\n    sep_inc = round(aug_inc * 1.2 + rnorm(52, 0, 10), digits = 0)\n    ) %>%\n    pivot_longer(\n        cols = c(july_inc, aug_inc, sep_inc),\n        names_to = \"month\",\n        values_to = \"incidence\",\n        names_pattern = \"(.*)_inc\",\n        data = .\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [156, 3]\nstate_id  int 1 1 1 2 2 2\nmonth     chr july aug sep july aug sep\nincidence dbl 399 613 725 409 578 685\n```\n\n\n:::\n:::\n\n\n\n\nBy default, the previous object gets input into the first argument of the next function, but here we've shown that you can manipulate the position the object is *piped* into by specify the argument using the `.` syntax.\n\n### `|>`\n\nIn `R` version 4.1.0, the `|>` was added as the base pipe operator.\nIt works slightly differently to `%>%`, and frankly, is less powerful and less common (at the moment), so we won't use it in this workshop.\n\n### `group_by()`\n\nIf we have groups in our **dataframe** and want to apply some function to each group's data, we can use the `group_by()` function.\nFor example, if we wanted to calculate the mean and median incidence in our fake data from earlier, but group it by the month.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(long_df, month) %>%\n    summarize(mean = mean(incidence), median = median(incidence))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [2, 3]\nmonth  chr aug july\nmean   dbl 599.057692 396.730769\nmedian dbl 600.5 398\n```\n\n\n:::\n:::\n\n\n\n\n### `pivot_*()` {#sec-pivot-functions}\n\nWe've [already seen](#tidy-data) the purpose of the `pivot_longer()` function: taking wide data and reshaping it to be long.\nThere is an equivalent to go from long to wide: `pivot_wider()`.\nOccassionally this is useful (though it is less common than creating long data).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(\n    long_df,\n    names_from = month,\n    values_from = incidence,\n    names_glue = \"{month}_inc\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [52, 3]\nstate_id int 1 2 3 4 5 6\njuly_inc int 399 409 381 381 387 372\naug_inc  int 613 578 604 607 603 614\n```\n\n\n:::\n:::\n\n\n\n\nHere, the `names_glue` argument is making use of the `glue::glue()` function ([see above](#sec-glue)) that is installed with `{tidyverse}`, but not loaded automatically for use by the users.\n\n### `map_*()` {#sec-map-functions}\n\nThe `map_*()` functions come from the `{purrr}` package (a core part of the `{tidyverse}`), and are incredibly useful.\nThey are relatively complicated, so there isn't enough space to go into full detail, but here we'll just outline enough so you can read more and understand what's going on.\n\nWe've [already seen](#anonymous-functions) we can apply functions to each element of a vector (**atomic** or **list** vectors).\nThe key points to note are the `.` preceding the `x` and `f` arguments.\nIf we use `map()` we get a **list** returned, `map_dbl()` a **double vector**, `map_char()` a **character vector**, `map_dfr()` a **dataframe** etc.\n\nIn the example below, we'll walk through `map_dfr()` as it's one of the more confusing variants due to the **return** requirements.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dfr_example <- map_dfr(\n    .x = my_dbl_vec,\n    .f = function(.x) {\n        # Note we don't use , at the end of each line - it's as if we were\n        # running the code in the console\n        times_ten <- .x * 10\n        divide_ten <- .x / 10\n\n        # construct a tibble as normal (requires , between arguments)\n        tibble(\n            original_val = .x,\n            times_ten = times_ten,\n            divide_ten = divide_ten\n        )\n    }\n)\n\nmap_dfr_example\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [10, 3]\noriginal_val int 1 2 3 4 5 6\ntimes_ten    dbl 10 20 30 40 50 60\ndivide_ten   dbl 0.1 0.2 0.3 0.4 0.5 0.6\n```\n\n\n:::\n:::\n\n\n\n\nWhat's happening under the hood is that `map_dfr()` is applying the [anonymous function](#anonymous-functions) we defined to each element in our vector and returning a **list** of **dataframes** that contains one row and three columns, i.e. for the first element, we would get this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(map_dfr_example[1, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\ntibble [1, 3]\noriginal_val int 1\ntimes_ten    dbl 10\ndivide_ten   dbl 0.1\n```\n\n\n:::\n:::\n\n\n\n\nIt then calls the `bind_rows()` function to *squash* all of those **dataframes** together, one row stacked on top of the next, to create one large **dataframe**.\nWe could write the equivalent code like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_rows(\n    map(\n    .x = my_dbl_vec,\n    .f = function(.x) {\n        # Note we don't use , at the end of each line - it's as if we were\n        # running the code in the console\n        times_ten <- .x * 10\n        divide_ten <- .x / 10\n\n        # construct a tibble as normal (requires , between arguments)\n        tibble(\n            original_val = .x,\n            times_ten = times_ten,\n            divide_ten = divide_ten\n        )\n    }\n)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [10, 3]\noriginal_val int 1 2 3 4 5 6\ntimes_ten    dbl 10 20 30 40 50 60\ndivide_ten   dbl 0.1 0.2 0.3 0.4 0.5 0.6\n```\n\n\n:::\n:::\n\n\n\n\n`map_dfc()` does exactly the same thing, but calls `bind_cols()` instead, to place the columns next to each other.\n\nThere is one more important variant to go through: `pmap_*()`.\nIf `map_*()` takes one vector as an argument, `pmap_*()` takes a **list** of arguments.\nWhat this means is that we can iterate through the elements of as many arguments as we'd like, *in sequence*.\nFor example, let's multiply the elements of two **double** vectors together.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a second vector of numbers\nmy_second_dbl_vec <- rnorm(length(my_dbl_vec), 20, 20)\nmy_second_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 45.583594  7.463083 20.505265 46.030180 15.004206 22.699967 17.066535\n [8] 44.678612 22.708520 21.344806\n```\n\n\n:::\n\n```{.r .cell-code}\n# Remind ourselves what our original vector looks like\nmy_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\npmap_dbl(\n    .l = list(first_num = my_dbl_vec, sec_num = my_second_dbl_vec),\n    .f = function(first_num, sec_num) {\n        first_num * sec_num\n    }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  45.58359  14.92617  61.51580 184.12072  75.02103 136.19980 119.46575\n [8] 357.42890 204.37668 213.44806\n```\n\n\n:::\n:::\n\n\n\n\nThere are a couple of important points to note here:\n\n- All vectors need to be the same length\n- The function is applied to each element index of the input vectors, i.e., the first elements of the vectors are multiplied together, the second element of the vectors are multiplied together, and so on, until the last elements are reached.\n- We use `.l` instead of `.x` to denote we are passing a `list()` of vectors.\n- Our function specifies the names of the vectors in the `list()`, which are then used within the function itself (similar to how we used `.x` in our `map_*()` functions)\n\n::: {.callout-note collapse=true}\nAs before, this is an unnecessary approach as `R` would vectorize the operation, but it is useful to demonstrate the principle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dbl_vec * my_second_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  45.58359  14.92617  61.51580 184.12072  75.02103 136.19980 119.46575\n [8] 357.42890 204.37668 213.44806\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### `nest()`\n\nNesting is a relatively complex, but powerful, concept, particularly when combined with the `map_*()` functions.\nCommonly, as in this workshop, it is used to apply a model function to multiple different datasets, and store them all in one **dataframe** for easy of manipulation.\nWhat it effectively does is group your existing **dataframe** by a variable, and then shrink all the columns (except the grouping column), into a single list column, leaving you with as many rows as there are distinct groups.\nEach element of the new list column is itself a small **dataframe** that contains all the original variables and data, but only those that are relevant for the group.\nHopefully this example will make it clearer.\nHere, we'll take the `mtcars` dataset, and like before, we'll group by the `cyl` variable, but this time we'll nest the rest of the data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnested_mtcars <- nest(mtcars, data = -cyl)\nnested_mtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3, 2]\ncyl  dbl 6 4 8\ndata lst tibble [7, 10] tibble [11, 10] tibble [14, 10]\n```\n\n\n:::\n:::\n\n\n\n\nWe can see we've nested all columns, *except* cyl.\nLooking at the `data` column for just the first row (`cyl == 6`), we see we have a list with one item: the rest of the data that's relevant to the rows where `cyl == 6` (notice the `[[1]]` above the **tibble**).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnested_mtcars[1, ]$data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\ntibble [7, 10]\nmpg  dbl 21 21 21.4 18.1 19.2 17.8\ndisp dbl 160 160 258 225 167.6 167.6\nhp   dbl 110 110 110 105 123 123\ndrat dbl 3.9 3.9 3.08 2.76 3.92 3.92\nwt   dbl 2.62 2.875 3.215 3.46 3.44 3.44\nqsec dbl 16.46 17.02 19.44 20.22 18.3 18.9\nvs   dbl 0 0 1 1 1 1\nam   dbl 1 1 0 0 0 0\ngear dbl 4 4 3 3 4 4\ncarb dbl 4 4 1 1 4 4\n```\n\n\n:::\n:::\n\n\n\n\nNow we can use `map` to fit a model to this subsetted data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    nested_mtcars,\n    model_fit = map(data, ~glm(mpg ~ hp + wt + ordered(carb), data = .x))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3, 3]\ncyl       dbl 6 4 8\ndata      lst tibble [7, 10] tibble [11, 10] tibble [14, 10]\nmodel_fit lst glm [30, 1] glm [30, 1] glm [30, 1]\n```\n\n\n:::\n:::\n\n\n\n\nThis creates a **list** column (because we used the `map()` function, which returns a list) that contains the relevant model fits.\n\n::: {.callout-important}\nIt is important to note that there is also a function called `nest_by()`.\nHowever, it  returns a `rowwise` **tibble**, i.e., any later manipulations will be applied on a row-by-row basis, unlike a standard **tibble** that applies the manipulation to every row all at once, so we would need to use normal `mutate()` syntax (and explicitly return a list column) to get the same effect as before.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnest_by(mtcars, .by = cyl) %>%\n    mutate(model_fit = list(glm(mpg ~ hp + wt + ordered(carb), data = data)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3, 3]\nrowwise grouped by: .by\n.by       dbl               4 6 8\ndata      list<tibble[,11]> 22.800, 24.400, 22.800, 32.400, 30.400, 33.900, 21.500, 27.300, 26.000,~\nmodel_fit lst               glm [30, 1] glm [30, 1] glm [30, 1]\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n### `ggplot()`\n\nTo create out plots, we can use the base `plot()` functions, but `{ggplot2}` package provides a clean and consistent interface to plotting that has many benefits.\nIn essence, plots are built up in layers, with each stacking on top of the previous.\n\nTo initialize a plot, we simply use the `ggplot()` function call, that creates the background of a figure.\nNow we need to add data, and **geoms** to interpret that data.\n\nLet's use the `mtcars` dataset again.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata.frame [32, 11]\nmpg  dbl 21 21 22.8 21.4 18.7 18.1\ncyl  dbl 6 6 4 6 8 6\ndisp dbl 160 160 108 258 360 225\nhp   dbl 110 110 93 110 175 105\ndrat dbl 3.9 3.9 3.85 3.08 3.15 2.76\nwt   dbl 2.62 2.875 2.32 3.215 3.44 3.46\nqsec dbl 16.46 17.02 18.61 19.44 17.02 20.22\nvs   dbl 0 0 1 1 0 1\nam   dbl 1 1 1 0 0 0\ngear dbl 4 4 4 3 3 3\ncarb dbl 4 4 1 1 2 1\n```\n\n\n:::\n:::\n\n\n\n\nLooking at the data, we might be interested in how the `mpg` of a car is affected by it horsepower (`hp`).\nTo add data, we just use the `ggplot()` function argument `data = mtcars`.\nWe also need to tell `ggplot()` how to map the data points to the figure, i.e., the values for the `x` and `y` axes.\n\n**Because this depends on the underlying data, this must go within an argument called `aes()` i.e., `aes(x = hp, y = mpg)`**.\n\nTo add a layer to show the data, we add a **geom**.\nIn this case, because we have continuous independent and dependent variables, we could use the `geom_point()` **geom**, that will give us a scatter plot.\nMuch like basic arithmetic, we *add* layers using the `+` operator.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = hp, y = mpg)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-60-1.png){width=100%}\n:::\n:::\n\n\n\n\nNow let's imagine we wanted to explore this relationship, but separated by engine type (the `vs` column).\nWe can use color to separate these points.\nBecause this is an argument that depends on the underlying data, again, this must be placed *within* `aes()`.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = hp, y = mpg, color = vs)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-61-1.png){width=100%}\n:::\n:::\n\n\n\n\nWhat you'll notice here is that despite `vs` being a binary choice, because it is of type **double**, `ggplot()` interprets this as a number, so provides a continuous color scale.\nTo correct this, let's convert `vs` into a factor before plotting.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg, color = vs)) +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-62-1.png){width=100%}\n:::\n:::\n\n\n\n\nWe can change the theme by layering in more information, as we did with the other plotting layers.\nHere, let's change the background to white, and add some different colors.\nWe'll also change the size of the points.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg, color = vs)) +\n    geom_point(size = 5) +\n    theme_minimal() +\n    # We don't need to specify the relationship between the levels and the colors\n    # and labels, but it means we're less likely to make a mistake in interpretation\n    # and labelling\n    scale_color_manual(\n        values = c(\"0\" = \"#6b3df5ff\", \"1\" = \"#f5c13cff\"),\n        labels = c(\"0\" = \"V-Shaped\", \"1\" = \"Straight\")\n    )\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-63-1.png){width=100%}\n:::\n:::\n\n\n\n\nImagine we wanted to use one more grouping: automatic vs manual transmission (`am`).\nRather than adding yet another color, we could do something called a `facet_wrap()`, which creates separate panels for each group.\nAdding this to a `ggplot()` is very easy - it's just another `+` operation!\nAs before, we will add labels for easier interpretation.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg, color = vs)) +\n    geom_point(size = 5) +\n    theme_minimal() +\n    # We don't need to specify the relationship between the levels and the colors\n    # and labels, but it means we're less likely to make a mistake in interpretation\n    # and labelling\n    scale_color_manual(\n        values = c(\"0\" = \"#6b3df5ff\", \"1\" = \"#f5c13cff\"),\n        labels = c(\"0\" = \"V-Shaped\", \"1\" = \"Straight\")\n    ) +\n    facet_wrap(~am, labeller = as_labeller(c(\"0\" = \"Automatic\", \"1\" = \"Manual\")))\n```\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-64-1.png){width=100%}\n:::\n:::\n\n\n\n\nThis is looking much better, but we might want to add a line to show the trends within the groups.\nAgain, this is as simple as adding another layer.\nOne thing to note about the plot below, because we specified the `data` and `aes()` arguments in the original `ggplot()` function call, those data relationships will also be applied to our new **geom**.\nWe could just as easily write them within the `geom_*()` explicitly, but then we would have to do that for each `geom_*()` in our plot, which is unnecessary when they all have the same data relationships.\nTo demonstrate this, let's also make a small modification so that only the points are colored, and the lines are all red.\nTo do that, we will remove `color = vs` from the global `aes()`, and add it to one specific to `geom_point()`.\nBut because we still want to fit a linear model to the different engine types (`vs`) separately, we will add `group = vs` to the `geom_smooth(aes(), ...)` call, to let `ggplot()` know to treat them as separate groups for the `geom_smooth()`\nBecause the line color doesn't depend on the data, it is not in an `aes()` argument call.\n\n\n\n\n::: {.cell .column-body}\n\n```{.r .cell-code}\nmtcars %>%\n    mutate(vs = factor(vs)) %>%\n    ggplot(aes(x = hp, y = mpg)) +\n    geom_point(aes(color = vs), size = 5) +\n    geom_smooth(aes(group = vs), color = \"red\", method = \"lm\") +\n    theme_minimal() +\n    # We don't need to specify the relationship between the levels and the colors\n    # and labels, but it means we're less likely to make a mistake in interpretation\n    # and labelling\n    scale_color_manual(\n        values = c(\"0\" = \"#6b3df5ff\", \"1\" = \"#f5c13cff\"),\n        labels = c(\"0\" = \"V-Shaped\", \"1\" = \"Straight\")\n    ) +\n    facet_wrap(~am, labeller = as_labeller(c(\"0\" = \"Automatic\", \"1\" = \"Manual\")))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](just-enough-r_files/figure-html/unnamed-chunk-65-1.png){width=100%}\n:::\n:::\n\n\n\n\nAs you can see, once you get used to it, the layering system makes it relatively intuitive to build complex and interesting plots.\nWe've only stratched the surface here, so be sure to read the [suggested books](#suggested-reading) and the [`{ggplot2}` cheatsheet](https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf) for more information.\n\n### `%*%`\n\nThis is the matrix multiplication operator.\nIt works exactly as you'd expect given matrix multiplication rules.\nAs such, you can use it on any combination of vectors and matrices.\n\n::: {.callout-important}\nAs you can see below, `R` treats vectors as dimensionless, and will try to convert it to *either* a row *or* column vector, depending on what makes sense for the matrix multiplication\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_dbl_vec %*% my_second_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         [,1]\n[1,] 1412.086\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(1:60, nrow = 10)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6]\n [1,]    1   11   21   31   41   51\n [2,]    2   12   22   32   42   52\n [3,]    3   13   23   33   43   53\n [4,]    4   14   24   34   44   54\n [5,]    5   15   25   35   45   55\n [6,]    6   16   26   36   46   56\n [7,]    7   17   27   37   47   57\n [8,]    8   18   28   38   48   58\n [9,]    9   19   29   39   49   59\n[10,]   10   20   30   40   50   60\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_dbl_vec %*% my_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]  385  935 1485 2035 2585 3135\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix %*% my_dbl_vec\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_matrix %*% my_dbl_vec: non-conformable arguments\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix %*% t(my_dbl_vec)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in my_matrix %*% t(my_dbl_vec): non-conformable arguments\n```\n\n\n:::\n\n```{.r .cell-code}\nt(my_matrix) %*% my_dbl_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  385\n[2,]  935\n[3,] 1485\n[4,] 2035\n[5,] 2585\n[6,] 3135\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}